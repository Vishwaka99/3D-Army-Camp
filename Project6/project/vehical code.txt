// armored_mrap.cpp
// Build a stylized armored MRAP-like vehicle using GLUT/GLU.
// No textures required; SOIL2 is included but unused.

#include <glut.h>
#include <math.h>
#include <SOIL2.h>
#include <stdio.h>
#include <vector>
#include <random>

// ---------- tiny color helper ----------
static inline void C(float r, float g, float b) { glColor3f(r, g, b); }

// ---------- portable cylinder (caps) ----------
static void solidCylinder(float r0, float r1, float h, int slices = 18, int stacks = 1) {
    GLUquadric* q = gluNewQuadric();
    gluCylinder(q, r0, r1, h, slices, stacks);
    glPushMatrix();                   // bottom cap
    gluDisk(q, 0.0, r0, slices, 1);
    glTranslatef(0, 0, h);              // top cap
    gluDisk(q, 0.0, r1, slices, 1);
    glPopMatrix();
    gluDeleteQuadric(q);
}

// ---------- basic shapes ----------
static void box(float sx, float sy, float sz) {
    glPushMatrix();
    glScalef(sx, sy, sz);
    glutSolidCube(1.0f);
    glPopMatrix();
}
static void xzRect(float x0, float z0, float x1, float z1, float y) {
    glBegin(GL_QUADS);
    glNormal3f(0, 1, 0);
    glVertex3f(x0, y, z0); glVertex3f(x1, y, z0); glVertex3f(x1, y, z1); glVertex3f(x0, y, z1);
    glEnd();
}

// ---------- wheels (axis along Z; easy to spin) ----------
static float g_wheelSpin = 0.0f;

static void wheel(float R = 0.9f, float W = 0.7f) {
    glPushMatrix();
    glRotatef(180, 1.0, 0, 0);             // cylinder axis -> Z
    glRotatef(g_wheelSpin, 0, 0, 1);     // rolling

    // Tire
    C(0.06f, 0.06f, 0.06f);
    solidCylinder(R, R, W, 24, 1);

    // Tread nubs
    for (int ring = 0; ring < 2; ++ring) {
        for (int i = 0;i < 18;++i) {
            glPushMatrix();
            glRotatef(i * (360.0f / 18), 0, 0, 1);
            glTranslatef(R - 0.06f, 0, W * (0.25f + 0.5f * ring));
            glScalef(0.14f, 0.36f, 0.18f);
            glutSolidCube(1.0f);
            glPopMatrix();
        }
    }

    // Rim + hub
    C(0.18f, 0.18f, 0.18f);
    glPushMatrix(); glTranslatef(0, 0, 0.02f);  gluDisk(gluNewQuadric(), 0.0, R * 0.62f, 24, 1); glPopMatrix();
    glPushMatrix(); glTranslatef(0, 0, W - 0.02f); gluDisk(gluNewQuadric(), 0.0, R * 0.62f, 24, 1); glPopMatrix();
    glPopMatrix();
}

// ---------- small details ----------
static void slitWindow(float w = 0.85f, float h = 0.42f) {
    C(0.18f, 0.22f, 0.26f);
    glBegin(GL_QUADS);
    glNormal3f(0, 0, 1);
    glVertex3f(-w * 0.5f, -h * 0.5f, 0);
    glVertex3f(w * 0.5f, -h * 0.5f, 0);
    glVertex3f(w * 0.5f, h * 0.5f, 0);
    glVertex3f(-w * 0.5f, h * 0.5f, 0);
    glEnd();

    // frame
    C(0.06f, 0.06f, 0.06f);
    glLineWidth(2.f);
    glBegin(GL_LINE_LOOP);
    glVertex3f(-w * 0.5f, -h * 0.5f, 0);
    glVertex3f(w * 0.5f, -h * 0.5f, 0);
    glVertex3f(w * 0.5f, h * 0.5f, 0);
    glVertex3f(-w * 0.5f, h * 0.5f, 0);
    glEnd();
}

static void grenadeLauncher(float tiltDeg = 28.f) {
    glPushMatrix();
    glRotatef(-tiltDeg, 1, 0, 0);
    C(0.16f, 0.16f, 0.17f);
    solidCylinder(0.11f, 0.11f, 0.9f, 12, 1);
    glTranslatef(0, 0, 0.9f);
    gluDisk(gluNewQuadric(), 0, 0.11f, 12, 1);
    glPopMatrix();
}

static void mirrorUnit() {
    C(0.08f, 0.08f, 0.08f);
    glPushMatrix();
    solidCylinder(0.03f, 0.03f, 0.5f, 10, 1); // stem
    glTranslatef(0, 0, 0.5f);
    box(0.35f, 0.45f, 0.08f);               // head
    glPopMatrix();
}

static void winch() {
    C(0.1f, 0.1f, 0.1f);
    glPushMatrix();
    box(0.9f, 0.30f, 0.40f);
    glTranslatef(0, -0.05f, 0.35f);
    solidCylinder(0.08f, 0.08f, 0.9f, 12, 1); // drum
    glPopMatrix();
}

// ---------- armored vehicle ----------
static void drawVehicle() {
    const float G = 1.0f; // ground clearance

    // Colors
    const float H0[3] = { 0.12f,0.13f,0.14f };     // very dark base
    const float H1[3] = { 0.16f,0.17f,0.19f };     // second tone
    const float MET[3] = { 0.20f,0.21f,0.23f };

    // ---------------- Hull lower (angled sides) ----------------
    C(H0[0], H0[1], H0[2]);
    glPushMatrix(); glTranslatef(0, G + 0.9f, 0); box(7.2f, 1.6f, 2.9f); glPopMatrix();

    // wheel arch armor (front & rear)
    C(H1[0], H1[1], H1[2]);
    glPushMatrix(); glTranslatef(2.4f, G + 1.15f, 0); box(1.6f, 0.7f, 3.2f); glPopMatrix();
    glPushMatrix(); glTranslatef(-2.4f, G + 1.15f, 0); box(1.6f, 0.7f, 3.2f); glPopMatrix();

    // ---------------- Upper cabin ----------------
    C(H1[0], H1[1], H1[2]);
    glPushMatrix(); glTranslatef(-0.4f, G + 2.0f, 0); box(5.0f, 1.0f, 2.6f); glPopMatrix();

    // Sloped windshield block
    glPushMatrix();
    C(H0[0] * 1.05f, H0[1] * 1.05f, H0[2] * 1.05f);
    glTranslatef(1.5f, G + 2.05f, 0);
    glRotatef(-20, 0, 0, 1);
    box(1.9f, 0.55f, 2.5f);
    glPopMatrix();

    // Hood plates
    glPushMatrix(); C(H0[0], H0[1], H0[2]); glTranslatef(2.7f, G + 1.55f, 0); box(1.3f, 0.35f, 2.5f); glPopMatrix();

    // Front bumper + winch
    glPushMatrix(); C(MET[0], MET[1], MET[2]); glTranslatef(3.7f, G + 1.0f, 0); box(0.9f, 0.7f, 2.8f); glPopMatrix();
    glPushMatrix(); glTranslatef(3.4f, G + 0.95f, 0); winch(); glPopMatrix();

    // Headlights
    glPushMatrix();
    glTranslatef(3.2f, G + 1.2f, 1.1f); C(0.85f, 0.80f, 0.55f); glutSolidSphere(0.18, 12, 10);
    glTranslatef(0, 0, -2.2f);         glutSolidSphere(0.18, 12, 10);
    glPopMatrix();

    // Mirrors
    glPushMatrix(); glTranslatef(1.0f, G + 1.9f, 1.6f); mirrorUnit(); glPopMatrix();
    glPushMatrix(); glTranslatef(1.0f, G + 1.9f, -1.6f); mirrorUnit(); glPopMatrix();

    // Side door slab (left)
    C(H0[0] * 0.95f, H0[1] * 0.95f, H0[2] * 0.95f);
    glPushMatrix(); glTranslatef(-0.8f, G + 1.6f, 1.33f); box(1.35f, 1.15f, 0.06f); glPopMatrix();

    // Small side windows (4 per side)
    for (int s = -1; s <= 1; s += 2) {
        float z = s * 1.33f;
        for (int i = 0;i < 4;++i) {
            glPushMatrix();
            glTranslatef(1.2f - i * 1.0f, G + 2.15f, z + 0.02f);
            if (s < 0) glRotatef(180, 0, 1, 0);
            slitWindow(0.7f, 0.42f);
            glPopMatrix();
        }
    }

    // Roof hatch/turret box
    C(H0[0] * 1.1f, H0[1] * 1.1f, H0[2] * 1.1f);
    glPushMatrix(); glTranslatef(0.0f, G + 2.65f, 0.0f); box(1.4f, 0.7f, 1.2f); glPopMatrix();

    // Roof grenade launchers (2×3)
    glPushMatrix(); glTranslatef(-0.2f, G + 2.55f, 0.6f); for (int i = 0;i < 3;++i) { glPushMatrix(); glTranslatef(i * 0.38f, 0, 0); grenadeLauncher(30); glPopMatrix(); } glPopMatrix();
    //glPushMatrix(); glTranslatef(-0.2f, G + 2.55f, -0.9f); glRotatef(180, 1, 0, 0); for (int i = 0;i < 3;++i) { glPushMatrix(); glTranslatef(i * 0.38f, 0, 0); grenadeLauncher(30); glPopMatrix(); } glPopMatrix();

    // Antennas
    /*C(0.08f, 0.08f, 0.09f);
    glPushMatrix(); glTranslatef(-2.2f, G + 2.3f, 1.2f); solidCylinder(0.03f, 0.03f, 2.8f, 10, 1); glPopMatrix();
    glPushMatrix(); glTranslatef(-3.0f, G + 2.3f, -1.2f); solidCylinder(0.03f, 0.03f, 2.6f, 10, 1); glPopMatrix();*/

    // Rear doors panel
    glPushMatrix(); glTranslatef(-3.6f, G + 1.6f, 0); C(H0[0], H0[1], H0[2]); box(0.5f, 1.6f, 2.2f); glPopMatrix();

    // Wheels (positions)
    C(0.06f, 0.06f, 0.06f);
    const float ax = 2.35f;   // fore–aft
    const float az = 1.25f;   // base lateral offset
    const float insetR = 0.15f;   // how much to push the RIGHT side inward

    // front-right  (z > 0)  -> moved inward by insetR
    glPushMatrix(); glTranslatef(ax, G, 2 - insetR); wheel(); glPopMatrix();
    // front-left   (z < 0)  -> unchanged
    glPushMatrix(); glTranslatef(ax, G, -az);          wheel(); glPopMatrix();
    // rear-right   (z > 0)  -> moved inward by insetR
    glPushMatrix(); glTranslatef(-ax, G, 2 - insetR); wheel(); glPopMatrix();
    // rear-left    (z < 0)  -> unchanged
    glPushMatrix(); glTranslatef(-ax, G, -az);          wheel(); glPopMatrix();

    // Mud flap (rear center)
    C(0.08f, 0.08f, 0.08f);
    glPushMatrix(); glTranslatef(-3.5f, G + 0.6f, 0); box(0.1f, 0.3f, 0.9f); glPopMatrix();
}

// ---------- environment ----------
static void initLights() {
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    GLfloat pos[] = { 60.f,80.f,40.f,1.f };
    GLfloat dif[] = { 1.f,1.f,1.f,1.f };
    GLfloat amb[] = { 0.25f,0.25f,0.28f,1.f };
    glLightfv(GL_LIGHT0, GL_POSITION, pos);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, dif);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, amb);
    glEnable(GL_COLOR_MATERIAL);
    glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
    glShadeModel(GL_SMOOTH);
}

static void ground() {
    // neutral studio floor
    C(0.78f, 0.78f, 0.78f);
    xzRect(-80, -60, 80, 60, 0.0f);
    // simple soft shadow blob
    /*C(0.0f, 0.0f, 0.0f);
    glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glColor4f(0, 0, 0, 0.14f);
    glPushMatrix(); glTranslatef(0, 0.01f, 0); glScalef(6.5f, 1, 3.8f); glutSolidSphere(1.0, 36, 18); glPopMatrix();
    glDisable(GL_BLEND);*/
}

// ---------- camera & input ----------
static float camYaw = 20.f, camPitch = 10.f, camDist = 38.f;

static void display() {
    glClearColor(0.92f, 0.92f, 0.93f, 1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // orbit camera
    const float cy = camDist * cosf(camPitch * 3.14159f / 180.f);
    const float ex = cy * sinf(camYaw * 3.14159f / 180.f);
    const float ez = cy * cosf(camYaw * 3.14159f / 180.f);
    const float ey = camDist * sinf(camPitch * 3.14159f / 180.f);
    gluLookAt(ex, 6.f + ey, ez, 0, 1.5f, 0, 0, 1, 0);

    ground();
    drawVehicle();

    glutSwapBuffers();
}

static void reshape(int w, int h) {
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, (float)w / (float)h, 0.5, 400.0);
    glMatrixMode(GL_MODELVIEW);
}

static void timer(int) {
    g_wheelSpin += 4.0f; if (g_wheelSpin > 360) g_wheelSpin -= 360;
    glutPostRedisplay();
    glutTimerFunc(33, timer, 0);
}

static void keyboard(unsigned char k, int, int) {
    if (k == 'a' || k == 'A') camYaw -= 5;
    if (k == 'd' || k == 'D') camYaw += 5;
    if (k == 'w' || k == 'W') camDist -= 1.5f;
    if (k == 's' || k == 'S') camDist += 1.5f;
    if (k == 'q' || k == 'Q') camPitch += 3;
    if (k == 'e' || k == 'E') camPitch -= 3;
    glutPostRedisplay();
}

// ---------- main ----------
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(1200, 720);
    glutCreateWindow("Armored MRAP (GLUT/GLU)");

    initLights();
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutTimerFunc(33, timer, 0);

    glutMainLoop();
    return 0;
}
